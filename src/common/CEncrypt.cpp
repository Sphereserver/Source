#include "graycom.h"
#include "grayproto.h"

//#define DEBUG_CRYPT_MSGS 1

CCrypt::CCrypt()
{
	// Always at least one crypt code, for non encrypted clients!
	if ( !sm_ClientCryptKeys.size() )
		addNoCryptKey();

	m_fInit = false;
	m_fRelayPacket = false;
	m_dwClientVersion = 0;
	m_EncryptionType = ENC_NONE;
	m_ConnectType = CONNECT_NONE;
	m_MasterLo = 0;
	m_MasterHi = 0;
	m_CryptMaskLo = 0;
	m_CryptMaskHi = 0;
	m_Seed = 0;

	// Blowfish
	m_gameTable = CRYPT_GAMETABLE_START;
	m_gameBlockPos = 0;
	m_gameStreamPos = 0;

	// Twofish
	memset(&tf_key, 0, sizeof(tf_key));
	memset(&tf_cipher, 0, sizeof(tf_cipher));
	tf_position = 0;
	md5_position = 0;
}

bool CCrypt::Init(DWORD dwIP, BYTE *pbEvent, size_t iLen, bool fClientKR)
{
	ADDTOCALLSTACK("CCrypt::Init");
	bool fReturn = true;

#ifdef DEBUG_CRYPT_MSGS
	DEBUG_ERR(("Initializing seed 0x%" FMTDWORDH "\n", dwIP));
#endif

	if ( iLen == 62 )	// SERVER_Login 1.26.0
	{
		LoginCryptStart(dwIP, pbEvent, iLen);
	}
	else
	{
		if ( fClientKR )
		{
			m_fInit = (SetConnectType(CONNECT_GAME) && SetEncryptionType(ENC_NONE));
			m_Seed = dwIP;
		}
		else if ( iLen == 65 )	// auto-registering server sending us info
		{
			GameCryptStart(dwIP, pbEvent, iLen);
		}
		else
		{
#ifdef DEBUG_CRYPT_MSGS
			DEBUG_MSG(("Odd login message length=%" FMTSIZE_T "\n", iLen));
#endif
			fReturn = false;
		}
	}

	m_fRelayPacket = false;
	return fReturn;
}

void CCrypt::InitFast(DWORD dwIP, CONNECT_TYPE type, bool fRelay)
{
	ADDTOCALLSTACK("CCrypt::InitFast");
	// Quickly set seed and connection type
	// ARGS:
	//  dwIP = seed
	//  type = connection type
	//  fRelay = switched via relay packet (server selection) / expect next game packet to be encrypted twice

	m_Seed = dwIP;
	SetConnectType(type);

	if ( type == CONNECT_GAME )
	{
		InitBlowfish();
		InitTwofish();
	}

	// No need to init game encryption here, we will only need to init again with a new seed on the next game packet anyway
	if ( fRelay )
		m_fRelayPacket = true;
}

void CCrypt::Encrypt(BYTE *pbOutput, const BYTE *pbInput, size_t iLen)
{
	ADDTOCALLSTACK("CCrypt::Encrypt");
	if ( !iLen )
		return;

	if ( m_ConnectType == CONNECT_LOGIN )
		return;

	if ( GetEncryptionType() == ENC_TFISH )
	{
		EncryptMD5(pbOutput, pbInput, iLen);
		return;
	}

	memcpy(pbOutput, pbInput, iLen);
}

void CCrypt::Decrypt(BYTE *pbOutput, const BYTE *pbInput, size_t iLen)
{
	ADDTOCALLSTACK("CCrypt::Decrypt");
	if ( !iLen )
		return;

	if ( m_ConnectType == CONNECT_LOGIN )
	{
		DecryptOld(pbOutput, pbInput, iLen);
		return;
	}

	if ( m_fRelayPacket )
	{
		RelayGameCryptStart(pbOutput, pbInput, iLen);
		return;
	}

	if ( GetEncryptionType() == ENC_NONE )
	{
		memcpy(pbOutput, pbInput, iLen);
		return;
	}

	if ( (GetEncryptionType() == ENC_TFISH) || (GetEncryptionType() == ENC_BTFISH) )
		DecryptTwofish(pbOutput, pbInput, iLen);
	if ( (GetEncryptionType() == ENC_BFISH) || (GetEncryptionType() == ENC_BTFISH) )
		DecryptBlowfish(pbOutput, (GetEncryptionType() == ENC_BTFISH) ? pbOutput : pbInput, iLen);
}

void CCrypt::DecryptOld(BYTE *pbOutput, const BYTE *pbInput, size_t iLen)
{
	ADDTOCALLSTACK("CCrypt::DecryptOld");
	if ( GetClientVer() >= 1253700 )	// >= 1.25.37
	{
		for ( size_t i = 0; i < iLen; ++i )
		{
			pbOutput[i] = pbInput[i] ^ static_cast<BYTE>(m_CryptMaskLo);
			DWORD MaskLo = m_CryptMaskLo;
			DWORD MaskHi = m_CryptMaskHi;
			m_CryptMaskLo = ((MaskLo >> 1) | (MaskHi << 31)) ^ m_MasterLo;
			MaskHi = ((MaskHi >> 1) | (MaskLo << 31)) ^ m_MasterHi;
			m_CryptMaskHi = ((MaskHi >> 1) | (MaskLo << 31)) ^ m_MasterHi;
		}
		return;
	}
	else if ( GetClientVer() == 1253600 )	// 1.25.36
	{
		for ( size_t i = 0; i < iLen; ++i )
		{
			pbOutput[i] = pbInput[i] ^ static_cast<BYTE>(m_CryptMaskLo);
			DWORD MaskLo = m_CryptMaskLo;
			DWORD MaskHi = m_CryptMaskHi;
			m_CryptMaskHi = (m_MasterHi >> ((5 * MaskHi * MaskHi) & 0xff)) + (MaskHi * m_MasterHi) + (MaskLo * MaskLo * 0x35ce9581) + 0x07afcc37;
			m_CryptMaskLo = (m_MasterLo >> ((3 * MaskLo * MaskLo) & 0xff)) + (MaskLo * m_MasterLo) - (m_CryptMaskHi * m_CryptMaskHi * 0x4c3a1353) + 0x16ef783f;
		}
		return;
	}
	else if ( GetClientVer() )	// <= 1.25.35
	{
		for ( size_t i = 0; i < iLen; ++i )
		{
			pbOutput[i] = pbInput[i] ^ static_cast<BYTE>(m_CryptMaskLo);
			DWORD MaskLo = m_CryptMaskLo;
			DWORD MaskHi = m_CryptMaskHi;
			m_CryptMaskLo = ((MaskLo >> 1) | (MaskHi << 31)) ^ m_MasterLo;
			m_CryptMaskHi = ((MaskHi >> 1) | (MaskLo << 31)) ^ m_MasterHi;
		}
		return;
	}

	if ( pbOutput != pbInput )
		memcpy(pbOutput, pbInput, iLen);
}

void CCrypt::LoginCryptStart(DWORD dwIP, BYTE *pbEvent, size_t iLen)
{
	ADDTOCALLSTACK("CCrypt::LoginCryptStart");
	ASSERT(pbEvent);

	BYTE bRaw[MAX_BUFFER];
	ASSERT(iLen <= sizeof(bRaw));
	memcpy(bRaw, pbEvent, iLen);

	m_Seed = dwIP;
	SetConnectType(CONNECT_LOGIN);
	TCHAR pszAccountNameCheck[MAX_ACCOUNT_NAME_SIZE];

	DWORD MaskLo = (((~m_Seed) ^ 0x00001357) << 16) | (((m_Seed) ^ 0xffffaaaa) & 0x0000ffff);
	DWORD MaskHi = (((m_Seed) ^ 0x43210000) >> 16) | (((~m_Seed) ^ 0xabcdffff) & 0xffff0000);

	SetClientVerIndex(0);
	SetCryptMask(MaskHi, MaskLo);

	for ( size_t i = 0; ; ++i )
	{
		if ( i >= sm_ClientCryptKeys.size() )
		{
			// Unknown client, set as unencrypted
#ifdef DEBUG_CRYPT_MSGS
			DEBUG_ERR(("LoginCrypt %" FMTSIZE_T " (unknown client)\n", i));
#endif
			SetClientVerIndex(0);
			SetCryptMask(MaskHi, MaskLo);
			break;
		}

		SetClientVerIndex(i);
		SetCryptMask(MaskHi, MaskLo);

		Decrypt(bRaw, pbEvent, iLen);

#ifdef DEBUG_CRYPT_MSGS
		DEBUG_ERR(("LoginCrypt %" FMTSIZE_T " (%" FMTDWORD ") type %hhx-%hhx\n", i, GetClientVer(), bRaw[0], pbEvent[0]));
#endif
		bool fValid = ((bRaw[0] == 0x80) && (bRaw[30] == 0x0) && (bRaw[60] == 0x0));
		if ( fValid )
		{
			// Sometimes client keys (like 4.0.0) can incorrectly intercept a login packet, making
			// it decrypt wrong info (strange chars after regular account name/password).
			// This prevents that fact, choosing the right keys to decrypt it correctly :)
			for ( size_t j = 21; j <= 30; ++j )
			{
				// No official client allows the account name/password to exceed 20 chars (2D=16, KR=20)
				// so chars 21-30 must be always 0x0 (some unofficial clients may allow the user exceed
				// it, but as they generally don't use encryption it shouldn't be a problem)
				if ( (bRaw[j] == 0x0) && (bRaw[j + 30] == 0x0) )
					continue;

				fValid = false;
				break;
			}

			if ( fValid )
			{
				LPCTSTR pszAccountNameRaw = reinterpret_cast<LPCTSTR>(bRaw + 1);
				if ( pszAccountNameRaw )
				{
					// (matex) TODO: What for? We do not really need pszAccountNameCheck here do we?!
					size_t iAccountNameLen = Str_GetBare(pszAccountNameCheck, pszAccountNameRaw, MAX_ACCOUNT_NAME_SIZE, ACCOUNT_NAME_INVALID_CHARS);
					if ( iAccountNameLen > 0 )
						pszAccountNameCheck[iAccountNameLen - 1] = '\0';

					if ( iAccountNameLen != strlen(pszAccountNameRaw) )
					{
						iAccountNameLen = 0;
						++i;
						continue;
					}
				}

				SetClientVerIndex(i);
				SetCryptMask(MaskHi, MaskLo);
				break;
			}
		}
	}

	m_fInit = true;
}

void CCrypt::GameCryptStart(DWORD dwIP, BYTE *pbEvent, size_t iLen)
{
	ADDTOCALLSTACK("CCrypt::GameCryptStart");
	ASSERT(pbEvent);

	BYTE bRaw[MAX_BUFFER];
	ASSERT(iLen <= sizeof(bRaw));
	memcpy(bRaw, pbEvent, iLen);

	m_Seed = dwIP;
	SetConnectType(CONNECT_GAME);

	bool fValid = false;
	for ( BYTE i = ENC_NONE; i < ENC_QTY; ++i )
	{
		SetEncryptionType(static_cast<ENCRYPTION_TYPE>(i));

		if ( (GetEncryptionType() == ENC_TFISH) || (GetEncryptionType() == ENC_BTFISH) )
			InitTwofish();
		if ( (GetEncryptionType() == ENC_BFISH) || (GetEncryptionType() == ENC_BTFISH) )
			InitBlowfish();

		Decrypt(bRaw, pbEvent, iLen);

#ifdef DEBUG_CRYPT_MSGS
		DEBUG_ERR(("GameCrypt %" FMTSIZE_T " (%" FMTDWORD ") type %hhx-%hhx\n", i, GetClientVer(), bRaw[0], pbEvent[0]));
#endif

		if ( (bRaw[0] == 0x91) && (bRaw[34] == 0x0) && (bRaw[64] == 0x0) )
		{
			fValid = true;
			break;
		}
	}

	if ( !fValid )
		SetEncryptionType(ENC_NONE);
	else
	{
		if ( (GetEncryptionType() == ENC_TFISH) || (GetEncryptionType() == ENC_BTFISH) )
			InitTwofish();
		if ( (GetEncryptionType() == ENC_BFISH) || (GetEncryptionType() == ENC_BTFISH) )
			InitBlowfish();
	}

	m_fInit = true;
}

void CCrypt::RelayGameCryptStart(BYTE *pbOutput, const BYTE *pbInput, size_t iLen)
{
	ADDTOCALLSTACK("CCrypt::RelayGameCryptStart");
	// When the client switches between login and game server without opening a new connection, the first game packet
	// is encrypted with both login and game server encryptions. This method attempts to initialse the game encryption
	// from this initial game packet.
	// If this wasn't inconvenient enough, it seems that not all client versions behave like this and some earlier ones
	// do properly switch over to game encryption:
	//  -Earliest confirmed "double Crypt" client = 6.0.1.6
	//  -Latest confirmed "single Crypt" client = 2.0.3.0

	m_fRelayPacket = false;

	if ( GetClientVer() < 2000400 )		// 2.0.4
	{
		// Clients < 2.0.4 do not double encrypt
		InitBlowfish();
		InitTwofish();
		Decrypt(pbOutput, pbInput, iLen);
		return;
	}

	DWORD dwNewSeed = m_MasterHi ^ m_MasterLo;
	dwNewSeed = ((dwNewSeed >> 24) & 0xFF) | ((dwNewSeed >> 8) & 0xFF00) | ((dwNewSeed << 8) & 0xFF0000) | ((dwNewSeed << 24) & 0xFF000000);
	dwNewSeed ^= m_Seed;

	m_Seed = dwNewSeed;
	md5_engine.reset();		// setting new seed requires a reset of the MD5 engine

	// Decrypt packet as game
	// Auto-detect encryption type by looking for 0x91 command if the packet length is 65 (which it should be anyway)
	ENCRYPTION_TYPE etPrevious = GetEncryptionType();
	bool fFoundEncrypt = false;
	if ( iLen == 65 )
	{
		for ( size_t i = ENC_NONE; i < ENC_QTY; ++i )
		{
			SetEncryptionType(static_cast<ENCRYPTION_TYPE>(i));
			InitBlowfish();
			InitTwofish();
			Decrypt(pbOutput, pbInput, iLen);

			if ( (pbOutput[0] ^ static_cast<BYTE>(m_CryptMaskLo)) == 0x91 )
			{
				fFoundEncrypt = true;
				break;
			}
		}
	}

	// Auto-detect failed, assume sphereCrypt.ini was correct and see what happens
	if ( !fFoundEncrypt )
	{
		SetEncryptionType(etPrevious);
		InitBlowfish();
		InitTwofish();
		Decrypt(pbOutput, pbInput, iLen);
	}

	// Decrypt decrypted packet as login
	DecryptOld(pbOutput, pbOutput, iLen);
}

void CCrypt::SetClientVer(const CCrypt &crypt)
{
	ADDTOCALLSTACK("CCrypt::SetClientVer");
	m_fInit = false;
	m_dwClientVersion = crypt.m_dwClientVersion;
	m_MasterLo = crypt.m_MasterLo;
	m_MasterHi = crypt.m_MasterHi;
}

bool CCrypt::SetClientVer(LPCTSTR pszVer)
{
	ADDTOCALLSTACK("CCrypt::SetClientVer(2)");
	m_fInit = false;
	DWORD dwVer = GetVerFromString(pszVer);
	if ( !SetClientVerEnum(dwVer) )
	{
		DEBUG_ERR(("Unsupported client version '%s'/'%" FMTDWORD "'\n", pszVer, dwVer));
		return false;
	}
	return true;
}

bool CCrypt::SetClientVerEnum(DWORD dwVer, bool fSetEncrypt)
{
	ADDTOCALLSTACK("CCrypt::SetClientVerEnum");
	dwVer -= dwVer % 100;	// ignore last digit (eg: 7.0.49.2 -> 7.0.49)
	for ( size_t i = 0; i < sm_ClientCryptKeys.size(); ++i )
	{
		CCryptClientKey *key = sm_ClientCryptKeys.at(i);
		if ( dwVer == key->m_Version )
		{
			if ( SetClientVerIndex(i, fSetEncrypt) )
				return true;
		}
	}
	return false;
}

bool CCrypt::SetClientVerIndex(size_t index, bool fSetEncrypt)
{
	ADDTOCALLSTACK("CCrypt::SetClientVerIndex");
	if ( index >= sm_ClientCryptKeys.size() )
		return false;

	CCryptClientKey *key = sm_ClientCryptKeys.at(index);
	SetClientVersion(key->m_Version);
	SetMasterKeys(key->m_Key1, key->m_Key2);

	if ( fSetEncrypt )
		SetEncryptionType(key->m_EncryptionType);
	return true;
}

DWORD CCrypt::GetVerFromString(LPCTSTR pszVer)
{
	ADDTOCALLSTACK("CCrypt::GetVerFromString");
	// Get version of old clients, which report the client version as ASCII string (eg: '5.0.2b')
	if ( (pszVer == NULL) || (*pszVer == '\0') )
		return 0;

	BYTE bLetter = 0;
	for ( size_t i = 0; i < strlen(pszVer); ++i )
	{
		if ( IsAlpha(pszVer[i]) )
		{
			bLetter = (pszVer[i] - 'a') + 1;
			break;
		}
	}

	TCHAR *ppVer[3];
	Str_ParseCmds(const_cast<TCHAR *>(pszVer), ppVer, COUNTOF(ppVer), ".");

	// Don't rely on all values reported by client, because it can be easily faked. Injection users can report any
	// client version they want, and some custom clients may also report client version as "Custom" instead X.X.Xy
	if ( !ppVer[0] || !ppVer[1] || !ppVer[2] || (bLetter > 26) )
		return 0;

	return (ATOI(ppVer[0]) * 1000000) + (ATOI(ppVer[1]) * 10000) + (ATOI(ppVer[2]) * 100) + bLetter;
}

DWORD CCrypt::GetVerFromNumber(DWORD dwMajor, DWORD dwMinor, DWORD dwRevision, DWORD dwPatch)
{
	ADDTOCALLSTACK("CCrypt::GetVerFromNumber");
	// Get version of new clients (5.0.6.5+), which report the client version as numbers (eg: 5,0,6,5)

	return (dwMajor * 1000000) + (dwMinor * 10000) + (dwRevision * 100) + dwPatch;
}

TCHAR *CCrypt::WriteClientVerString(DWORD dwVer, TCHAR *pszOutput)
{
	ADDTOCALLSTACK("CCrypt::WriteClientVerString");
	if ( dwVer >= MINCLIVER_NEWVERSIONING )
	{
		sprintf(pszOutput, "%" FMTDWORD ".%" FMTDWORD ".%" FMTDWORD ".%" FMTDWORD, dwVer / 1000000, (dwVer / 10000) % 100, (dwVer % 10000) / 100, dwVer % 100);
	}
	else
	{
		int iVer = sprintf(pszOutput, "%" FMTDWORD ".%" FMTDWORD ".%" FMTDWORD, dwVer / 1000000, (dwVer / 10000) % 100, (dwVer % 10000) / 100);
		int iPatch = static_cast<int>(dwVer % 100);
		if ( iPatch )
		{
			pszOutput[iVer++] = static_cast<TCHAR>(iPatch + 'a' - 1);
			pszOutput[iVer] = '\0';
		}
	}
	return pszOutput;
}

///////////////////////////////////////////////////////////
// Client encryption keys table

std::vector<CCryptClientKey *> CCrypt::sm_ClientCryptKeys;

void CCrypt::addNoCryptKey()
{
	ADDTOCALLSTACK("CCrypt::addNoCryptKey");
	CCryptClientKey *key = new CCryptClientKey;
	key->m_Version = 0;
	key->m_Key1 = 0;
	key->m_Key2 = 0;
	key->m_EncryptionType = ENC_NONE;
	sm_ClientCryptKeys.push_back(key);
}

void CCrypt::LoadKeyTable(CScript &s)
{
	ADDTOCALLSTACK("CCrypt::LoadKeyTable");
	ClearKeyTable();
	addNoCryptKey();	// always add nocrypt

	while ( s.ReadKeyParse() )
	{
		CCryptClientKey *key = new CCryptClientKey;
		key->m_Version = ahextoi(s.GetKey());
		key->m_Key1 = s.GetArgVal();
		key->m_Key2 = s.GetArgVal();
		key->m_EncryptionType = static_cast<ENCRYPTION_TYPE>(s.GetArgVal());
		sm_ClientCryptKeys.push_back(key);
	}
}

void CCrypt::ClearKeyTable()
{
	ADDTOCALLSTACK("CCrypt::ClearKeyTable");
	for ( size_t i = 0; i < sm_ClientCryptKeys.size(); ++i )
	{
		CCryptClientKey *key = sm_ClientCryptKeys.at(i);
		delete key;
	}
	sm_ClientCryptKeys.clear();
}

///////////////////////////////////////////////////////////
// Blowfish

static DWORD sm_dwCodingData[CRYPT_GAMEKEY_COUNT][18 + 1024];

static const DWORD sm_dwInitData[18 + 1024] =
{
	// @0106248 in v2.0.3
	// @0107248 in v2.0.4 (but not used, go figure)
	// sm_p_box
	0x243F6A88, 0x85A308D3, 0x13198A2E, 0x03707344, 0xA4093822, 0x299F31D0, 0x082EFA98, 0xEC4E6C89,
	0x452821E6, 0x38D01377, 0xBE5466CF, 0x34E90C6C, 0xC0AC29B7, 0xC97C50DD, 0x3F84D5B5, 0xB5470917,
	0x9216D5D9, 0x8979FB1B,

	// sm_s_box
	0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7, 0xb8e1afed, 0x6a267e96, 0xba7c9045, 0xf12c7f99,
	0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16, 0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e,
	0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee, 0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013,
	0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef, 0x8e79dcb0, 0x603a180e, 0x6c9e0e8b, 0xb01e8a3e,
	0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60, 0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440,
	0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce, 0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a,
	0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e, 0xafd6ba33, 0x6c24cf5c, 0x7a325381, 0x28958677,
	0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193, 0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032,
	0xef845d5d, 0xe98575b1, 0xdc262302, 0xeb651b88, 0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239,
	0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e, 0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0,
	0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3, 0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98,
	0xa1f1651d, 0x39af0176, 0x66ca593e, 0x82430e88, 0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe,
	0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6, 0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d,
	0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b, 0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7,
	0xe3fe501a, 0xb6794c3b, 0x976ce0bd, 0x04c006ba, 0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463,
	0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f, 0x6dfc511f, 0x9b30952c, 0xcc814544, 0xaf5ebd09,
	0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3, 0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb,
	0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279, 0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8,
	0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab, 0x323db5fa, 0xfd238760, 0x53317b48, 0x3e00df82,
	0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db, 0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573,
	0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0, 0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b,
	0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790, 0xe1ddf2da, 0xa4cb7e33, 0x62fb1341, 0xcee4c6e8,
	0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4, 0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0,
	0xd08ed1d0, 0xafc725e0, 0x8e3c5b2f, 0x8e7594b7, 0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c,
	0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad, 0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1,
	0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299, 0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9,
	0x165fa266, 0x80957705, 0x93cc7314, 0x211a1477, 0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf,
	0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49, 0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af,
	0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa, 0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5,
	0x83260376, 0x6295cfa9, 0x11c81968, 0x4e734a41, 0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915,
	0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400, 0x08ba6fb5, 0x571be91f, 0xf296ec6b, 0x2a0dd915,
	0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664, 0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a,
	0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623, 0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266,
	0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1, 0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e,
	0x3f54989a, 0x5b429d65, 0x6b8fe4d6, 0x99f73fd6, 0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1,
	0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e, 0x09686b3f, 0x3ebaefc9, 0x3c971814, 0x6b6a70a1,
	0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737, 0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8,
	0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff, 0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd,
	0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701, 0x3ae5e581, 0x37c2dadc, 0xc8b57634, 0x9af3dda7,
	0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41, 0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331,
	0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf, 0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af,
	0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e, 0x5512721f, 0x2e6b7124, 0x501adde6, 0x9f84cd87,
	0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c, 0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2,
	0xef1c1847, 0x3215d908, 0xdd433b37, 0x24c2ba16, 0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd,
	0x71dff89e, 0x10314e55, 0x81ac77d6, 0x5f11199b, 0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509,
	0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e, 0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3,
	0x771fe71c, 0x4e3d06fa, 0x2965dcb9, 0x99e71d0f, 0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a,
	0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4, 0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960,
	0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66, 0xe3bc4595, 0xa67bc883, 0xb17f37d1, 0x018cff28,
	0xc332ddef, 0xbe6c5aa5, 0x65582185, 0x68ab9802, 0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84,
	0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510, 0x13cca830, 0xeb61bd96, 0x0334fe1e, 0xaa0363cf,
	0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14, 0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e,
	0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50, 0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7,
	0x9b540b19, 0x875fa099, 0x95f7997e, 0x623d7da8, 0xf837889a, 0x97e32d77, 0x11ed935f, 0x16681281,
	0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99, 0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696,
	0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128, 0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73,
	0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0, 0x45eee2b6, 0xa3aaabea, 0xdb6c4f15, 0xfacb4fd0,
	0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105, 0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250,
	0xcf62a1f2, 0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3, 0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285,
	0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00, 0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061,
	0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb, 0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e,
	0xa6078084, 0x19f8509e, 0xe8efd855, 0x61d99735, 0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc,
	0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9, 0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340,
	0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20, 0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7,
	0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934, 0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068,
	0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af, 0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840,
	0x4d95fc1d, 0x96b591af, 0x70f4ddd3, 0x66a02f45, 0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504,
	0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a, 0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb,
	0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee, 0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6,
	0xaace1e7c, 0xd3375fec, 0xce78a399, 0x406b2a42, 0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b,
	0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2, 0x3a6efa74, 0xdd5b4332, 0x6841e7f7, 0xca7820fb,
	0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527, 0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b,
	0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33, 0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c,
	0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3, 0x95c11548, 0xe4c66d22, 0x48c1133f, 0xc70f86dc,
	0x07f9c9ee, 0x41041f0f, 0x404779a4, 0x5d886e17, 0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564,
	0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b, 0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115,
	0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922, 0x85b2a20e, 0xe6ba0d99, 0xde720c8c, 0x2da2f728,
	0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0, 0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e,
	0x0a476341, 0x992eff74, 0x3a6f6eab, 0xf4f8fd37, 0xa812dc60, 0xa1ebddf8, 0x991be14c, 0xdb6e6b0d,
	0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804, 0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b,
	0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3, 0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb,
	0x37392eb3, 0xcc115979, 0x8026e297, 0xf42e312d, 0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c,
	0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350, 0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9,
	0x44421659, 0x0a121386, 0xd90cec6e, 0xd5abea2a, 0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe,
	0x9dbc8057, 0xf0f7c086, 0x60787bf8, 0x6003604d, 0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc,
	0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f, 0x77a057be, 0xbde8ae24, 0x55464299, 0xbf582e61,
	0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2, 0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9,
	0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2, 0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c,
	0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e, 0xb77f19b6, 0xe0a9dc09, 0x662d09a1, 0xc4324633,
	0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10, 0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169,
	0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52, 0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027,
	0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5, 0xf0177a28, 0xc0f586e0, 0x006058aa, 0x30dc7d62,
	0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634, 0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76,
	0x6f05e409, 0x4b7c0188, 0x39720a3d, 0x7c927c24, 0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc,
	0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4, 0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c,
	0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837, 0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0,
	0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b, 0x5cb0679e, 0x4fa33742, 0xd3822740, 0x99bc9bbe,
	0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b, 0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4,
	0x5748ab2f, 0xbc946e79, 0xc6a376d2, 0x6549c2c8, 0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6,
	0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304, 0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22,
	0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4, 0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6,
	0x2826a2f9, 0xa73a3ae1, 0x4ba99586, 0xef5562e9, 0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59,
	0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593, 0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51,
	0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28, 0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c,
	0xe029ac71, 0xe019a5e6, 0x47b0acfd, 0xed93fa9b, 0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28,
	0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c, 0x15056dd4, 0x88f46dba, 0x03a16125, 0x0564f0bd,
	0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a, 0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319,
	0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb, 0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f,
	0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991, 0xea7a90c2, 0xfb3e7bce, 0x5121ce64, 0x774fbe32,
	0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680, 0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166,
	0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae, 0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb,
	0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5, 0x72eacea8, 0xfa6484bb, 0x8d6612ae, 0xbf3c6f47,
	0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370, 0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d,
	0x4040cb08, 0x4eb4e2cc, 0x34d2466a, 0x0115af84, 0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048,
	0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8, 0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd,
	0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9, 0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7,
	0x1a908749, 0xd44fbd9a, 0xd0dadecb, 0xd50ada38, 0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f,
	0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c, 0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525,
	0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1, 0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442,
	0xe0ec6e0e, 0x1698db3b, 0x4c98a0be, 0x3278e964, 0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e,
	0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8, 0xdf359f8d, 0x9b992f2e, 0xe60b6f47, 0x0fe3f11d,
	0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f, 0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299,
	0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02, 0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc,
	0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614, 0xe6c6c7bd, 0x327a140a, 0x45e1d006, 0xc3f27b9a,
	0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6, 0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b,
	0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0, 0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060,
	0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e, 0x1948c25c, 0x02fb8a8c, 0x01c36ae4, 0xd6ebe1f9,
	0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f, 0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6
};

const BYTE CCrypt::sm_KeyTable[CRYPT_GAMEKEY_COUNT][CRYPT_GAMEKEY_LENGTH] =
{
	// @ 0f1420 in v2.0.3
	// @ 0f2420 in v2.0.4 (but not used, go figure)
	{ 0x91, 0x3C, 0x2B, 0x0F, 0x44, 0xC6 },
	{ 0x0C, 0x96, 0xD2, 0x40, 0x93, 0x21 },
	{ 0xF2, 0x12, 0xA5, 0xAA, 0xDA, 0xE9 },
	{ 0x9A, 0xD4, 0xF7, 0x14, 0x97, 0xD0 },
	{ 0xFC, 0xC9, 0xC7, 0xD6, 0xA8, 0xA3 },
	{ 0x7B, 0x67, 0x36, 0x9B, 0x0B, 0x1A },
	{ 0x03, 0xAC, 0xF9, 0x02, 0xAE, 0x2D },
	{ 0x01, 0x77, 0x79, 0x6B, 0x0C, 0x67 },
	{ 0xA4, 0xB4, 0x1E, 0xD7, 0xAA, 0x51 },
	{ 0xD6, 0xE1, 0xBC, 0x27, 0x15, 0x25 },
	{ 0x17, 0x17, 0x47, 0x65, 0x40, 0x8B },
	{ 0xB8, 0x19, 0xDB, 0x4E, 0x17, 0x74 },
	{ 0xAA, 0x63, 0xAC, 0x37, 0xA0, 0x8F },
	{ 0x77, 0xCD, 0x5D, 0x23, 0xEF, 0xB7 },
	{ 0x13, 0x2B, 0x83, 0xBF, 0x0F, 0x8C },
	{ 0xB1, 0x0B, 0xC8, 0x6F, 0x39, 0x4D },
	{ 0xA1, 0xA5, 0xFA, 0x2B, 0xC6, 0xE2 },
	{ 0x9C, 0x29, 0xCC, 0x26, 0xE9, 0x2D },
	{ 0xCD, 0x6F, 0xD2, 0xCA, 0xBE, 0x47 },
	{ 0x9B, 0x21, 0xAE, 0x3E, 0x31, 0x69 },
	{ 0xE7, 0x0B, 0xE6, 0x6F, 0xCF, 0x91 },
	{ 0x88, 0x59, 0xAF, 0x90, 0xC5, 0x2D },
	{ 0xAE, 0xD2, 0x52, 0xB5, 0x28, 0x98 },
	{ 0x3B, 0x7F, 0x65, 0xED, 0x5E, 0x93 },
	{ 0x30, 0xBF, 0x0A, 0x34, 0xDB, 0x3D }
};

bool CCrypt::sm_fTablesReady = false;

void CCrypt::InitTables()	// static
{
	ADDTOCALLSTACK("CCrypt::InitTables");
	for ( size_t i = 0; i < CRYPT_GAMEKEY_COUNT; ++i )
	{
		memcpy(sm_dwCodingData[i], sm_dwInitData, COUNTOF(sm_dwInitData) - 1);

		DWORD dwCode[3];
		dwCode[0] = (sm_KeyTable[i][0] << 24) + (sm_KeyTable[i][1] << 16) + (sm_KeyTable[i][2] << 8) + sm_KeyTable[i][3];
		dwCode[1] = (sm_KeyTable[i][4] << 24) + (sm_KeyTable[i][5] << 16) + (sm_KeyTable[i][0] << 8) + sm_KeyTable[i][1];
		dwCode[2] = (sm_KeyTable[i][2] << 24) + (sm_KeyTable[i][3] << 16) + (sm_KeyTable[i][4] << 8) + sm_KeyTable[i][5];

		for ( size_t j = 0; j < 18; ++j )
			sm_dwCodingData[i][j] ^= dwCode[j % 3];

		CCrypt::CCryptKey tmpKey;
		tmpKey.dwKey[0] = tmpKey.dwKey[1] = 0;

		for ( size_t j = 0; j < 0x412; j += 2 )
		{
			PrepareKey(tmpKey, i);
			sm_dwCodingData[i][j + 0] = tmpKey.dwKey[1];
			sm_dwCodingData[i][j + 1] = tmpKey.dwKey[0];
		}
	}
	sm_fTablesReady = true;
}

void CCrypt::PrepareKey(CCrypt::CCryptKey &key, size_t iTable)	// static
{
	ADDTOCALLSTACK("CCrypt::PrepareKey");
	const DWORD *pdwCodes = sm_dwCodingData[iTable];

	key.dwKey[1] ^= pdwCodes[0];
	for ( size_t i = 0; i < 8; ++i )
	{
		key.dwKey[0] ^= pdwCodes[i * 2 + 1] ^ (((pdwCodes[18 + key.bKey[7]] + pdwCodes[18 + key.bKey[6] + 0x100]) ^ pdwCodes[18 + key.bKey[5] + 0x200]) + pdwCodes[18 + key.bKey[4] + 0x300]);
		key.dwKey[1] ^= pdwCodes[i * 2 + 2] ^ (((pdwCodes[18 + key.bKey[3]] + pdwCodes[18 + key.bKey[2] + 0x100]) ^ pdwCodes[18 + key.bKey[1] + 0x200]) + pdwCodes[18 + key.bKey[0] + 0x300]);
	}
	key.dwKey[0] ^= pdwCodes[17];

	DWORD dwTemp = key.dwKey[0];
	key.dwKey[0] = key.dwKey[1];
	key.dwKey[1] = dwTemp;
}

void CCrypt::InitBlowfish()
{
	ADDTOCALLSTACK("CCrypt::InitBlowfish");
	if ( !sm_fTablesReady )
		InitTables();

	m_gameTable = CRYPT_GAMETABLE_START;
	InitSeed(0);
}

const BYTE CCrypt::sm_SeedTable[2][CRYPT_GAMEKEY_COUNT][2][CRYPT_GAMESEED_LENGTH] =
{
	// Seed Table - Much of this table is never used.
	// @0f14b8 in v2.0.3
	// @0f24b8 in v2.0.4 (but not used, go figure)
	{
		{ { 0x9E, 0xEC, 0x5B, 0x3C, 0x8F, 0xA8, 0x8C, 0x55 }, { 0xB6, 0x21, 0x71, 0x98, 0xA4, 0x47, 0x22, 0x58 } },
		{ { 0xF8, 0xC4, 0xD8, 0x72, 0x54, 0xFC, 0xF9, 0xDE }, { 0x2D, 0x53, 0xDB, 0x32, 0x03, 0x10, 0x5A, 0x18 } },	// first keys
		{ { 0x89, 0x9F, 0x5C, 0x53, 0x06, 0x7F, 0x44, 0x38 }, { 0x32, 0xCE, 0xAC, 0xDB, 0x91, 0x44, 0x4E, 0x1E } },
		{ { 0x29, 0x78, 0x5A, 0xF0, 0xAB, 0x00, 0x7F, 0x91 }, { 0xE6, 0xB6, 0xD2, 0xE7, 0xA0, 0x05, 0xC2, 0xF2 } },
		{ { 0x8D, 0x46, 0xA9, 0xBB, 0x52, 0x1B, 0x41, 0xDF }, { 0xF0, 0x4A, 0xC9, 0x14, 0x27, 0xA9, 0x6B, 0x4A } },
		{ { 0x91, 0x4B, 0x8A, 0x80, 0xF5, 0xCF, 0xBB, 0x3C }, { 0xBC, 0xF4, 0xC9, 0xD5, 0x42, 0x7A, 0xFA, 0xB7 } },
		{ { 0xD5, 0x8C, 0x01, 0xC0, 0xFD, 0x1E, 0xAA, 0x57 }, { 0xC1, 0x20, 0x7A, 0x38, 0x2C, 0xB7, 0xCD, 0x14 } },
		{ { 0x55, 0x9F, 0xD1, 0x5B, 0xFB, 0x70, 0xC0, 0x77 }, { 0xA4, 0x15, 0xB3, 0x9F, 0x6B, 0xBB, 0x10, 0x5A } },
		{ { 0x80, 0x9D, 0x16, 0x54, 0x6B, 0x7C, 0x5F, 0xAD }, { 0x35, 0xCB, 0x92, 0x24, 0x08, 0x11, 0xD9, 0x61 } },
		{ { 0x24, 0xA7, 0x75, 0xBF, 0x4D, 0x7E, 0x70, 0x0C }, { 0x90, 0xCF, 0x9C, 0x04, 0xAC, 0x53, 0x89, 0xEF } },
		{ { 0x99, 0x22, 0xF6, 0x89, 0x10, 0xE6, 0x72, 0x23 }, { 0x0A, 0x5C, 0xA5, 0xFF, 0x9C, 0x78, 0xDA, 0x7F } },
		{ { 0xDF, 0xFF, 0xBB, 0x11, 0x6B, 0x75, 0xF0, 0x29 }, { 0xA5, 0x86, 0xD0, 0x53, 0x77, 0xE7, 0xB1, 0x0D } },
		{ { 0x4C, 0x06, 0xDA, 0x55, 0x4E, 0x50, 0x1B, 0x7A }, { 0x1C, 0x90, 0xCE, 0x64, 0xD6, 0x17, 0x52, 0xFB } },
		{ { 0x00, 0x26, 0x75, 0x25, 0xCD, 0x95, 0x15, 0x0F }, { 0x13, 0xD8, 0xAB, 0x30, 0xF1, 0xC5, 0xC5, 0xFA } },
		{ { 0x0C, 0x8E, 0x86, 0x1E, 0x3F, 0xCB, 0x8B, 0xD1 }, { 0xEC, 0xCE, 0xA9, 0x96, 0x91, 0x11, 0xB4, 0x97 } },
		{ { 0x1E, 0x65, 0x5F, 0xA4, 0x55, 0xEB, 0xEC, 0xCF }, { 0x19, 0xD9, 0x9F, 0xE0, 0x5E, 0x57, 0x45, 0x73 } },
		{ { 0x0E, 0x2D, 0x18, 0xE1, 0x55, 0x05, 0x04, 0xBF }, { 0x5E, 0x81, 0x1F, 0xDD, 0xFF, 0x5C, 0xC3, 0xF4 } },
		{ { 0xF2, 0x06, 0x56, 0x54, 0x4D, 0xFB, 0x96, 0x54 }, { 0x33, 0x97, 0x07, 0x43, 0x4F, 0x39, 0xC4, 0xA8 } },
		{ { 0x5E, 0x02, 0x37, 0x17, 0x7B, 0x64, 0xE6, 0xA2 }, { 0x2E, 0x24, 0x13, 0x07, 0xFE, 0xA1, 0x88, 0xB7 } },
		{ { 0x60, 0xDD, 0x4C, 0xE0, 0xA1, 0xDC, 0xBA, 0x6C }, { 0x81, 0x5C, 0x3F, 0x93, 0x7A, 0x1F, 0x2A, 0x1C } },
		{ { 0xAE, 0x5C, 0xBE, 0x9D, 0x84, 0x6F, 0xCB, 0x51 }, { 0x4D, 0x13, 0xC6, 0x81, 0x28, 0xC3, 0x03, 0x34 } },
		{ { 0xB0, 0x5D, 0xCB, 0x8D, 0x69, 0x1C, 0xDE, 0x29 }, { 0x31, 0xF1, 0x22, 0xC3, 0x1C, 0x82, 0x8A, 0x57 } },
		{ { 0x08, 0x32, 0x8B, 0xA2, 0x1E, 0x12, 0xC9, 0xB9 }, { 0xCD, 0xA8, 0xE6, 0x1C, 0x59, 0xAC, 0x0C, 0xF6 } },
		{ { 0xA5, 0x3B, 0xE4, 0x64, 0x2F, 0x45, 0x33, 0xA2 }, { 0x4A, 0xDA, 0x39, 0xE2, 0x0E, 0x94, 0xF2, 0xAA } },
		{ { 0xB0, 0x82, 0xB7, 0x33, 0xD2, 0x6F, 0xC0, 0x00 }, { 0xD7, 0x8D, 0x1F, 0x8E, 0x79, 0x85, 0x3E, 0x2A } },
	},
	{
		{ { 0xD2, 0xB7, 0xF6, 0x9C, 0xCF, 0x06, 0xE8, 0xC1 }, { 0xAE, 0xEB, 0x7F, 0xE9, 0x87, 0x28, 0x1C, 0x9B } },
		{ { 0xE8, 0x8C, 0x2A, 0x97, 0xD1, 0xD2, 0xA6, 0x76 }, { 0xAD, 0x23, 0x69, 0xA0, 0xEF, 0x1F, 0x8C, 0xBA } },
		{ { 0x24, 0x62, 0x40, 0x0B, 0x21, 0xC6, 0x07, 0x89 }, { 0xBA, 0x60, 0x9E, 0x26, 0x98, 0x18, 0xAF, 0x01 } },
		{ { 0xDF, 0x2B, 0x56, 0xC9, 0xB3, 0x72, 0x35, 0x8D }, { 0x1D, 0x4F, 0x61, 0xAF, 0x53, 0x12, 0x6E, 0x49 } },
		{ { 0x1C, 0x87, 0x6C, 0xB1, 0xD4, 0x1B, 0xA2, 0xB2 }, { 0xD4, 0xA1, 0x2C, 0xE2, 0x2F, 0xE9, 0xA4, 0x62 } },
		{ { 0x17, 0x83, 0x1C, 0x68, 0xB3, 0xD6, 0x65, 0x2D }, { 0x81, 0x5B, 0x4D, 0x9B, 0x15, 0x6F, 0x0B, 0xDF } },
		{ { 0xCE, 0x91, 0xB9, 0x8A, 0x61, 0x20, 0xB1, 0xF9 }, { 0xCA, 0x0A, 0xC4, 0x76, 0x5B, 0x4B, 0xAB, 0x16 } },
		{ { 0x5B, 0xD2, 0x4A, 0xFD, 0x44, 0xB7, 0xDF, 0x1F }, { 0x8B, 0x6F, 0xAB, 0x0C, 0xAB, 0x3D, 0x0C, 0x7A } },
		{ { 0x35, 0x6C, 0xBD, 0xFF, 0x62, 0x53, 0x77, 0x44 }, { 0xF2, 0x44, 0x5F, 0x8C, 0x59, 0x25, 0x5F, 0x6B } },
		{ { 0xB5, 0x27, 0x0D, 0xD2, 0x23, 0xBE, 0x40, 0xB3 }, { 0x3E, 0x8B, 0x92, 0xB1, 0x78, 0x57, 0xCB, 0xB0 } },
		{ { 0xB3, 0xB4, 0xB6, 0xD5, 0xB6, 0xA7, 0x66, 0x6E }, { 0xFB, 0xA7, 0x32, 0x93, 0xEE, 0x79, 0x61, 0x45 } },
		{ { 0x49, 0xD7, 0x93, 0x34, 0x90, 0x1A, 0xAD, 0x2C }, { 0x84, 0x3E, 0xE9, 0x0B, 0x2C, 0xC6, 0xB3, 0xB1 } },
		{ { 0x82, 0xFB, 0x86, 0xEC, 0xA8, 0x76, 0x55, 0x98 }, { 0x7E, 0xE3, 0xA2, 0x47, 0xB6, 0x72, 0x05, 0x61 } },
		{ { 0x0B, 0xA5, 0x72, 0x17, 0xCB, 0x18, 0xAE, 0x03 }, { 0x8C, 0x61, 0x32, 0xD9, 0x2B, 0x42, 0xEF, 0xF2 } },
		{ { 0x3F, 0x0A, 0x06, 0x82, 0x09, 0xC9, 0x76, 0xF2 }, { 0x3D, 0x54, 0x50, 0xFD, 0x25, 0xA2, 0x2F, 0x2E } },
		{ { 0xF1, 0x34, 0x64, 0x94, 0xDC, 0x90, 0x58, 0x5D }, { 0x1E, 0x6F, 0xB4, 0xEF, 0x73, 0xE8, 0xB0, 0xED } },
		{ { 0xC0, 0xD2, 0xE1, 0x42, 0xEC, 0x04, 0x69, 0xA8 }, { 0x27, 0x9C, 0x7C, 0x79, 0x87, 0x9A, 0xB2, 0x48 } },
		{ { 0x50, 0x73, 0xEC, 0x1E, 0x4D, 0xD0, 0x80, 0x51 }, { 0x46, 0x21, 0xC9, 0xF8, 0x93, 0xCC, 0xE8, 0x41 } },
		{ { 0x70, 0xC9, 0xE4, 0x78, 0x8F, 0x6B, 0x2C, 0x27 }, { 0x4C, 0x7E, 0x2C, 0x5A, 0x15, 0x69, 0x64, 0xDD } },
		{ { 0x00, 0xC7, 0x09, 0xCD, 0xF6, 0x2D, 0x2D, 0x31 }, { 0x6F, 0x01, 0x01, 0x3E, 0xCD, 0x60, 0x16, 0xB4 } },
		{ { 0xE7, 0xE8, 0x76, 0xC4, 0x50, 0x4F, 0x08, 0x5B }, { 0x62, 0x28, 0x24, 0x42, 0x7D, 0x9A, 0x19, 0x26 } },
		{ { 0x2F, 0xD4, 0x67, 0xB9, 0x24, 0x0C, 0xBB, 0x14 }, { 0x7D, 0x19, 0xC8, 0x73, 0x79, 0xA7, 0x70, 0xCF } },
		{ { 0x2D, 0x53, 0xDC, 0x91, 0x83, 0xF2, 0x0C, 0x12 }, { 0x3B, 0xAF, 0x1B, 0x6B, 0x02, 0x99, 0x8B, 0x61 } },
		{ { 0xE3, 0x2C, 0xA2, 0x54, 0xCD, 0x51, 0xAF, 0xE5 }, { 0x18, 0x58, 0x11, 0x7F, 0xF0, 0x50, 0x9C, 0x15 } },
		{ { 0x6E, 0x26, 0x01, 0xE9, 0xDB, 0x50, 0x13, 0xEA }, { 0x22, 0x59, 0x30, 0x3B, 0xE4, 0x5F, 0x43, 0x1E } }
	}
};

void CCrypt::InitSeed(size_t iTable)
{
	ADDTOCALLSTACK("CCrypt::InitSeed");
	const BYTE *pbKey = sm_SeedTable[iTable][m_gameTable][0];
	for ( int i = CRYPT_GAMESEED_LENGTH - 1; i >= 0; --i )
		m_Key.bKey[i] = *pbKey++;

	m_gameBlockPos = 0;
	m_gameStreamPos = 0;
}

void CCrypt::DecryptBlowfish(BYTE *pbOutput, const BYTE *pbInput, size_t iLen)
{
	ADDTOCALLSTACK("CCrypt::DecryptBlowfish");
	while ( m_gameStreamPos + iLen > CRYPT_GAMETABLE_TRIGGER )
	{
		size_t iLenOld = CRYPT_GAMETABLE_TRIGGER - m_gameStreamPos;
		DecryptBlowfish(pbOutput, pbInput, iLenOld);
		m_gameTable = (m_gameTable + CRYPT_GAMETABLE_STEP) % CRYPT_GAMETABLE_MODULO;
		InitSeed(1);

		pbOutput += iLenOld;
		pbInput += iLenOld;
		iLen -= iLenOld;
	}

	for ( size_t i = 0; i < iLen; ++i )
		pbOutput[i] = DecryptBlowfishByte(pbInput[i]);

	m_gameStreamPos += iLen;
}

BYTE CCrypt::DecryptBlowfishByte(BYTE bEnc)
{
	ADDTOCALLSTACK("CCrypt::DecryptBlowfishByte");
	if ( !m_gameBlockPos )
	{
		PrepareKey(m_Key, m_gameTable);
		m_gameBlockPos = 8;
	}
	--m_gameBlockPos;

	BYTE bResult = bEnc ^ m_Key.bKey[m_gameBlockPos];
	m_Key.bKey[m_gameBlockPos] = bEnc;
	return bResult;
}

///////////////////////////////////////////////////////////
// Twofish

void CCrypt::InitTwofish()
{
	ADDTOCALLSTACK("CCrypt::InitTwofish");
	memset(&tf_key, 0, sizeof(tf_key));
	memset(&tf_cipher, 0, sizeof(tf_cipher));
	tf_position = 0;

	makeKey(&tf_key, DIR_DECRYPT, 0x80, NULL);
	cipherInit(&tf_cipher, MODE_ECB, NULL);

	DWORD dwIP = UNPACKDWORD(reinterpret_cast<BYTE *>(&m_Seed));
	tf_key.key32[0] = tf_key.key32[1] = tf_key.key32[2] = tf_key.key32[3] = dwIP; //0x7f000001;
	reKey(&tf_key);

	for ( size_t i = 0; i < TFISH_RESET; ++i )
		tf_cipherTable[i] = static_cast<BYTE>(i);

	BYTE bTempBuff[TFISH_RESET];
	memset(&bTempBuff, 0, sizeof(bTempBuff));
	blockEncrypt(&tf_cipher, &tf_key, &tf_cipherTable[0], 0x800, &bTempBuff[0]);
	memcpy(&tf_cipherTable, &bTempBuff, sizeof(tf_cipherTable));

	if ( GetEncryptionType() == ENC_TFISH )
		InitMD5(&bTempBuff[0]);
}

void CCrypt::DecryptTwofish(BYTE *pbOutput, const BYTE *pbInput, size_t iLen)
{
	ADDTOCALLSTACK("CCrypt::DecryptTwofish");
	BYTE bTempBuff[TFISH_RESET];
	memset(&bTempBuff, 0, sizeof(bTempBuff));

	for ( size_t i = 0; i < iLen; ++i )
	{
		if ( tf_position >= TFISH_RESET )
		{
			blockEncrypt(&tf_cipher, &tf_key, &tf_cipherTable[0], 0x800, &bTempBuff[0]);
			memcpy(&tf_cipherTable, &bTempBuff, sizeof(tf_cipherTable));
			tf_position = 0;
		}
		pbOutput[i] = pbInput[i] ^ tf_cipherTable[tf_position++];
	}
}

///////////////////////////////////////////////////////////
// MD5

void CCrypt::InitMD5(BYTE *pbInitialize)
{
	ADDTOCALLSTACK("CCrypt::InitMD5");
	md5_position = 0;
	md5_engine.update(pbInitialize, TFISH_RESET);
	md5_engine.finalize();
	md5_engine.numericDigest(&md5_digest[0]);
}

void CCrypt::EncryptMD5(BYTE *pbOutput, const BYTE *pbInput, size_t iLen)
{
	ADDTOCALLSTACK("CCrypt::EncryptMD5");
	for ( size_t i = 0; i < iLen; ++i )
	{
		pbOutput[i] = pbInput[i] ^ md5_digest[md5_position++];
		md5_position &= MD5_RESET;
	}
}

///////////////////////////////////////////////////////////
// CHuffman

const WORD CHuffman::sm_xCompress_Base[COMPRESS_TREE_SIZE] =	// static
{
	// The "golden" key for (0.0.0.0)
	// lowest 4 bits is the length. other source uses 2 int's per WORD here.
	// @ 014b389 in 2.0.3
	// @ 010a3d8 in 2.0.4
	0x0002, 0x01f5, 0x0226, 0x0347, 0x0757, 0x0286, 0x03b6, 0x0327,
	0x0e08, 0x0628, 0x0567, 0x0798, 0x19d9, 0x0978, 0x02a6, 0x0577,
	0x0718, 0x05b8, 0x1cc9, 0x0a78, 0x0257, 0x04f7, 0x0668, 0x07d8,
	0x1919, 0x1ce9, 0x03f7, 0x0909, 0x0598, 0x07b8, 0x0918, 0x0c68,
	0x02d6, 0x1869, 0x06f8, 0x0939, 0x1cca, 0x05a8, 0x1aea, 0x1c0a,
	0x1489, 0x14a9, 0x0829, 0x19fa, 0x1719, 0x1209, 0x0e79, 0x1f3a,
	0x14b9, 0x1009, 0x1909, 0x0136, 0x1619, 0x1259, 0x1339, 0x1959,
	0x1739, 0x1ca9, 0x0869, 0x1e99, 0x0db9, 0x1ec9, 0x08b9, 0x0859,
	0x00a5, 0x0968, 0x09c8, 0x1c39, 0x19c9, 0x08f9, 0x18f9, 0x0919,
	0x0879, 0x0c69, 0x1779, 0x0899, 0x0d69, 0x08c9, 0x1ee9, 0x1eb9,
	0x0849, 0x1649, 0x1759, 0x1cd9, 0x05e8, 0x0889, 0x12b9, 0x1729,
	0x10a9, 0x08d9, 0x13a9, 0x11c9, 0x1e1a, 0x1e0a, 0x1879, 0x1dca,
	0x1dfa, 0x0747, 0x19f9, 0x08d8, 0x0e48, 0x0797, 0x0ea9, 0x0e19,
	0x0408, 0x0417, 0x10b9, 0x0b09, 0x06a8, 0x0c18, 0x0717, 0x0787,
	0x0b18, 0x14c9, 0x0437, 0x0768, 0x0667, 0x04d7, 0x08a9, 0x02f6,
	0x0c98, 0x0ce9, 0x1499, 0x1609, 0x1baa, 0x19ea, 0x39fa, 0x0e59,
	0x1949, 0x1849, 0x1269, 0x0307, 0x06c8, 0x1219, 0x1e89, 0x1c1a,
	0x11da, 0x163a, 0x385a, 0x3dba, 0x17da, 0x106a, 0x397a, 0x24ea,
	0x02e7, 0x0988, 0x33ca, 0x32ea, 0x1e9a, 0x0bf9, 0x3dfa, 0x1dda,
	0x32da, 0x2eda, 0x30ba, 0x107a, 0x2e8a, 0x3dea, 0x125a, 0x1e8a,
	0x0e99, 0x1cda, 0x1b5a, 0x1659, 0x232a, 0x2e1a, 0x3aeb, 0x3c6b,
	0x3e2b, 0x205a, 0x29aa, 0x248a, 0x2cda, 0x23ba, 0x3c5b, 0x251a,
	0x2e9a, 0x252a, 0x1ea9, 0x3a0b, 0x391b, 0x23ca, 0x392b, 0x3d5b,
	0x233a, 0x2cca, 0x390b, 0x1bba, 0x3a1b, 0x3c4b, 0x211a, 0x203a,
	0x12a9, 0x231a, 0x3e0b, 0x29ba, 0x3d7b, 0x202a, 0x3adb, 0x213a,
	0x253a, 0x32ca, 0x23da, 0x23fa, 0x32fa, 0x11ca, 0x384a, 0x31ca,
	0x17ca, 0x30aa, 0x2e0a, 0x276a, 0x250a, 0x3e3b, 0x396a, 0x18fa,
	0x204a, 0x206a, 0x230a, 0x265a, 0x212a, 0x23ea, 0x3acb, 0x393b,
	0x3e1b, 0x1dea, 0x3d6b, 0x31da, 0x3e5b, 0x3e4b, 0x207a, 0x3c7b,
	0x277a, 0x3d4b, 0x0c08, 0x162a, 0x3daa, 0x124a, 0x1b4a, 0x264a,
	0x33da, 0x1d1a, 0x1afa, 0x39ea, 0x24fa, 0x373b, 0x249a, 0x372b,
	0x1679, 0x210a, 0x23aa, 0x1b8a, 0x3afb, 0x18ea, 0x2eca, 0x0627,
	0x00d4 // terminator
};

size_t CHuffman::Compress(BYTE *pbOutput, const BYTE *pbInput, size_t iLen)	// static
{
	ADDTOCALLSTACK("CHuffman::Compress");
	BYTE bOutVal = 0;		// don't bother to init this, it will just roll off all junk anyhow
	size_t iOutLen = 0;
	WORD wBitIndex = 0;		// offset in output byte (bOutVal)

	for ( size_t i = 0; i <= iLen; i++ )
	{
		WORD wValue = sm_xCompress_Base[(i == iLen) ? COMPRESS_TREE_SIZE - 1 : pbInput[i]];
		int iBits = wValue & 0xF;
		wValue >>= 4;
		while ( iBits-- )
		{
			bOutVal <<= 1;
			bOutVal |= (wValue >> iBits) & 0x1;
			if ( ++wBitIndex == 8 )
			{
				wBitIndex = 0;
				pbOutput[iOutLen++] = bOutVal;
			}
		}
	}
	if ( wBitIndex )	// flush odd bits
		pbOutput[iOutLen++] = bOutVal << (8 - wBitIndex);
	return iOutLen;
}
